import numpy as np
import matplotlib.pyplot as plt
import time


# --- 1. Метод прогонки (Томаса) ---
def thomas_algorithm(a, b, c, d):
    """
    Решает трёхдиагональную систему Ax = d методом прогонки.
    """
    n = len(b)
    alpha = np.zeros(n - 1)
    beta = np.zeros(n)

    # прямой ход
    alpha[0] = c[0] / b[0]
    beta[0] = d[0] / b[0]

    for i in range(1, n - 1):
        denom = b[i] - a[i - 1] * alpha[i - 1]
        alpha[i] = c[i] / denom
        beta[i] = (d[i] + a[i - 1] * beta[i - 1]) / denom

    # последний элемент
    beta[n - 1] = (d[n - 1] + a[n - 2] * beta[n - 2]) / (b[n - 1] - a[n - 2] * alpha[n - 2])

    # обратный ход
    x = np.zeros(n)
    x[-1] = beta[-1]
    for i in range(n - 2, -1, -1):
        x[i] = alpha[i] * x[i + 1] + beta[i]

    return x


# --- 2. Генерация случайной трёхдиагональной матрицы ---
def generate_tridiagonal_matrix(n, seed=None):
    if seed is not None:
        np.random.seed(seed)

    a = np.random.uniform(0.5, 2.0, n - 1)  # поддиагональ
    b = np.random.uniform(2.5, 5.0, n)  # главная диагональ
    c = np.random.uniform(0.5, 2.0, n - 1)  # наддиагональ

    # усилим диагональное преобладание
    for i in range(n):
        off_sum = 0
        if i > 0:
            off_sum += a[i - 1]
        if i < n - 1:
            off_sum += c[i]
        b[i] = abs(b[i]) + off_sum + 1.0  # гарантированное преобладание

    # создадим полную матрицу для проверки
    A = np.zeros((n, n))
    np.fill_diagonal(A, b)
    np.fill_diagonal(A[1:], -a)
    np.fill_diagonal(A[:, 1:], -c)

    return A, a, b, c


# --- 3. Проверка на точном решении ---
def test_thomas(n):
    # создаем матрицу
    A, a, b, c = generate_tridiagonal_matrix(n, seed=42)

    # точное решение x̄ = [0, 1, 2, ..., n-1]
    x_true = np.arange(n, dtype=float)

    # правая часть b = A * x̄
    d = A @ x_true

    # решаем систему
    x_num = thomas_algorithm(a, b, c, d)

    # погрешность
    error = np.linalg.norm(x_true - x_num) / np.linalg.norm(x_true)
    return error


# --- 4. Проверим асимптотику ---
sizes = [100, 500, 1000, 2000, 5000, 10000]
times = []
errors = []

for n in sizes:
    A, a, b, c = generate_tridiagonal_matrix(n)
    x_true = np.arange(n, dtype=float)
    d = A @ x_true

    start = time.perf_counter()
    x_num = thomas_algorithm(a, b, c, d)
    end = time.perf_counter()

    times.append(end - start)
    errors.append(np.linalg.norm(x_true - x_num) / np.linalg.norm(x_true))

# --- 5. Графики ---
plt.figure(figsize=(10, 4))

plt.subplot(1, 2, 1)
plt.plot(sizes, times, "o-", label="Время решения")
plt.xlabel("Размер системы n")
plt.ylabel("Время, сек")
plt.title("Зависимость времени от размера системы")
plt.grid(True)
plt.legend()

plt.subplot(1, 2, 2)
plt.plot(sizes, errors, "s--", color="red", label="Относительная ошибка")
plt.xlabel("Размер системы n")
plt.ylabel("Ошибка")
plt.title("Точность метода прогонки")
plt.grid(True)
plt.legend()

plt.tight_layout()
plt.show()

# Выведем финальные результаты
for n, t, e in zip(sizes, times, errors):
    print(f"n={n:6d} | время = {t:.6f} с | ошибка = {e:.2e}")

